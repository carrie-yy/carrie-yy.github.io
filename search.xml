<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java泛型]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言：泛型是jdk5引入的类型机制，将类型参数化。泛型机制将类型转换时的检查从运行时提前到了编译时，使用泛型编写的代码比杂乱的使用Object并在需要时在强制类型转换的机制具有更好的可读性和安全性。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法 一、什么是泛型1.1 引入泛型之前在Java增加泛型类型之前，通用程序的设计就是利用继承实现的，例如，ArrayList类只维护一个Object引用的数组，Object为所有类基类。12345678910111213141516171819202122232425public class BeforeGeneric &#123; static class ArrayList&#123;//泛型之前的通用程序设计 private Object[] elements=new Object[0]; public Object get(int i)&#123; return elements[i]; &#125; public void add(Object o)&#123; //这里的实现，只是为了演示，不具有任何参考价值 int length=elements.length; Object[] newElments=new Object[length+1]; for(int i=0;i&lt;length;i++)&#123; newElments[i]=elements[i]; &#125; newElments[length]=o; elements=newElments; &#125; &#125; public static void main(String[] args) &#123; ArrayList stringValues=new ArrayList(); stringValues.add(1);//可以向数组中添加任何类型的对象 //问题1——获取值时必须强制转换 String str=(String) stringValues.get(0); //问题2——上述强制转型编译时不会出错，而运行时报异常java.lang.ClassCastException &#125;&#125; 这样的实现面临两个问题： 1、当我们获取一个值的时候，必须进行强制类型转换。 2、假定我们预想的是利用stringValues来存放String集合，因为ArrayList只是维护一个Object引用的数组，我们无法阻止将Integer类型（Object子类）的数据加入stringValues。然而，当我们使用数据的时候，需要将获取的Object对象转换为我们期望的类型（String），如果向集合中添加了非预期的类型（如Integer），编译时我们不会收到任何的错误提示。但当我们运行程序时却会报异常： Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Stringat generic.BeforeGeneric.main(BeforeGeneric.java:24) 这显然不是我们所期望的，如果程序有潜在的错误，我们更期望在编译时被告知错误，而不是在运行时报异常 1.2 泛型程序设计意味着程序可以被不同类型的对象重用，类似c++的模版泛型提供了更好的解决办法——类型参数，如： 1List&lt;String&gt; list = new ArrayList&lt;String&gt;()； 这样解决了几个问题： 1 可读性，从字面上就可以判断集合中的内容类型；2 类型检查，避免插入非法类型。3 获取数据时不在需要强制类型转换。 二、泛型使用2.1 泛型类泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）： 123456class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123; private 泛型标识 /*（成员变量类型）*/ var; ..... &#125;&#125; 举个例子 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 12345678//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型//传入的实参类型需与泛型的类型参数类型相同，即为Integer.Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);//传入的实参类型需与泛型的类型参数类型相同，即为String.Generic&lt;String&gt; genericString = new Generic&lt;String&gt;("key_vlaue");Log.d("泛型测试","key is " + genericInteger.getKey());Log.d("泛型测试","key is " + genericString.getKey()); 12-27 09:20:04.432 13063-13063/? D/泛型测试: key is 12345612-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue 定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。 看一个例子： 123456789Generic generic = new Generic("111111");Generic generic1 = new Generic(4444);Generic generic2 = new Generic(55.55);Generic generic3 = new Generic(false);Log.d("泛型测试","key is " + generic.getKey());Log.d("泛型测试","key is " + generic1.getKey());Log.d("泛型测试","key is " + generic2.getKey());Log.d("泛型测试","key is " + generic3.getKey()); 1234D/泛型测试: key is 111111D/泛型测试: key is 4444D/泛型测试: key is 55.55D/泛型测试: key is false 2.2 泛型接口泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： 1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类，传入泛型实参时： 2.3 泛型方法三、Java泛型实现方法：类型擦除 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。 123456789List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();if(classStringArrayList.equals(classIntegerArrayList))&#123; Log.d("泛型测试","类型相同");&#125; 输出结果：D/泛型测试: 类型相同。 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 123456789public class Test4 &#123; public static void main(String[] args) throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; ArrayList&lt;Integer&gt; arrayList3=new ArrayList&lt;Integer&gt;(); arrayList3.add(1);//这样调用add方法只能存储整形，因为泛型类型的实例为Integer arrayList3.getClass().getMethod("add", Object.class).invoke(arrayList3, "asd"); for (int i=0;i&lt;arrayList3.size();i++) &#123; System.out.println(arrayList3.get(i)); &#125; &#125; 在程序中定义了一个ArrayList泛型类型实例化为Integer的对象，如果直接调用add方法，那么只能存储整形的数据。不过当我们利用反射调用add方法的时候，却可以存储字符串。这说明了Integer泛型实例在编译之后被擦除了，只保留了&lt;font color=’red&gt;’原始类型。&lt;/ 对此总结成一句话：也就是说Java中的泛型，只在编译阶段有效。泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 类型擦除后保留的原始类型 原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。 123456789class Pair&lt;T&gt; &#123; private T value; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125;&#125; Pair的原始类型为： 12345678910class Pair &#123; private Object value; public Object getValue() &#123; return value; &#125; public void setValue(Object value) &#123; this.value = value; &#125;&#125; 因为在Pair中，T是一个无限定的类型变量，所以用Object替换。其结果就是一个普通的类，如同泛型加入java变成语言之前已经实现的那样。在程序中可以包含不同类型的Pair，如Pair或Pair，但是，擦除类型后它们就成为原始的Pair类型了，原始类型都是Object。从上面的那个例2中，我们也可以明白ArrayList被擦除类型后，原始类型也变成了Object，所以通过反射我们就可以存储字符串了。 如果类型变量有限定，那么原始类型就用第一个边界的类型变量来替换。 比如Pair这样声明 1public class Pair&lt;T extends Comparable&amp; Serializable&gt; &#123;&#125; 那么原始类型就是Comparable注意： 如果Pair这样声明 1public class Pair&lt;T extends Serializable&amp;Comparable&gt;&#123;&#125; 那么原始类型就用Serializable替换，而编译器在必要的时要向Comparable插入强制类型转换 为了提高效率，应该将标签（tagging）接口（即没有方法的接口）放在边界限定列表的末尾。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo +GitHub Pages 搭建个人博客]]></title>
    <url>%2F2019%2F02%2F15%2FHexo%2BGitHub%20Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言在学习过程中发现琐碎的只是难以系统化，随意学习使用博客方式方便自己维护和系统总结——– 记录自己尝试搭建个人博客的过程。工具：GitHub pages 、Hexo、Node.js 1. 使用GitHub在自己主页创建一个新的版本库 配置GitHub Pages: 进去版本库，点击右上角Settings。选择一个主题 至此，我们已经配置好了github默认的静态站点，并且可以访问：你的github用户名.github.io测试我们刚刚建立好的站点主页。 2. 安装git2.1. 官网下载并安装git https://git-scm.com/download/win2.2. 测试是否安装成功** windows+R输入cmd打开命令提示符窗口，输入如下命令： git --version 若安装成功会打印出本机安装的git的版本。 2.3 添加SSH KEY到Github​ SSH Key是一个认证，让github识别绑定这台机器，允许这台机器提交 2.3.1 检测本机是否有设置 SSHKEY 打开git bash，输入cd ~/.ssh 或cd .ssh如果没有则提示： No such file or directory如果有则进入~/.ssh路径下（ls查看当前路径文件，rm * 删除所有文件 2.3.2. 生成SSHKEY12345678910$ cd ~ #保证当前路径在”~”下$ ssh-keygen -t rsa -C "这里填写你的邮箱地址"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa): #不填直接回车Enter passphrase (empty for no passphrase): #输入密码（可以为空）Enter same passphrase again: #再次确认密码（可以为空）Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa. #生成的密钥Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub. #生成的公钥The key fingerprint is:e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxxxxx@yy.com 至此，已经生成ssh key，其存放路径为：c:/Users/你电脑的用户名/.ssh/下。 2.3.3. 复制SSH KEY到Github ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 1到C盘你的用户目录下找到.ssh文件夹，查看里面是否有id_rsa和id_rsa.pub这两个文件。 登录GitHub系统；点击右上角账号头像的“▼”→Settings→SSH kyes→Add SSH key，Title自定义，复制id_rsa.pub的公钥内容到GitHub中Add an SSH key的key输入框，最后“Add Key”。 2.3.4. 配置账户123$ git config --global user.name “your_username” #设置用户名$ git config --global user.email “your_registered_github_Email” #设置邮箱地址(建议用注册giuhub的邮箱) 2.3.5. 测试SSH KEY是否设置成功1$ ssh -T git@github.com 接下来会返回一些信息，并需要你输入一次yes，若生成ssh key时设置有密码则还会让你输入生成ssh key时设置的密码。 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. #出现词句话，说明设置成功。 SSH-KEY的生成与配置可参考图文教程window下配置SSH连接GitHub、GitHub配置ssh key： 3. 安装Node.js 和配置 Hexo3.1 安装Node.js Node.js官网 https://nodejs.org/en/download/ 下载安装node.js。 具体安装教程可参考 https://www.cnblogs.com/fanyx/p/6946039.html 3.2 安装配置Hexo hexo是基于node.js的静态博客，官网也是搭建在GitHub上。前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 3.2.1 安装Hexo 1npm install -g hexo-cli 如果执行这条命令时长时间未成功，那么请先使用下面的命令将npm镜像源更改为国内的镜像，再执行上面的安装命令，因为国外的镜像源很有可能被墙了。 1npm config set registry https://registry.npm.taobao.org 查看是否安装成功 hexo -v 有版本号输出表示安装成功 3.2.2 初始化Hexo123hexo -init hexo //这里会将Github上的hexo项目clone下来，得到hexo文件夹。初始化成功后会在最后打印一行：INFO Start blogging with Hexo!cd hexo // 进入文件夹npm install // 初始化博客 初始化完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 3.2.3 部署文件为了检测我们的网站雏形，分别按顺序输入以下三条命令： 123hexo new 'MyFirstBlog'hexo generatehexo server 在浏览器输入：http://localhost:4000/ 即可访问到我们搭建好的hexo站点。 现在来介绍常用的Hexo 命令 npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客 命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。 4. 将本地hexo项目托管到Github上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，如下图 进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，如下图 下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为： deploy:type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: master 参考如下： 保存站点配置文件。 其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。 最后安装Git部署插件，输入命令： 1npm install hexo-deployer-git --save 部署到Github上依次执行以下三条命令： 123$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令$ hexo generator #生成静态页面至public目录$ hexo deploy #将.deploy目录部署到GitHub 执行hexo deploy命令之后，如果最后一行打印出如下信息则表示部署成功 1INFO Deploy done: git 然后你再去访问你创建的Github pages地址，也就是：你的Github用户名.github.io，即可看到你本地的hexo项目已经被部署到github上去了。此时博客的默认主题是landscape，即上面本地测试时的样子。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
</search>
